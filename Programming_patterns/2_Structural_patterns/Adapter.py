'''
Основная идея:

- Адаптер оборачивает объект с несовместимым интерфейсом и предоставляет клиенту совместимый интерфейс.
- Это полезно, когда вы хотите использовать существующий класс, но его интерфейс не соответствует вашим требованиям.

Типы адаптеров:

- Адаптер на основе классов (Class Adapter):
    Использует множественное наследование для адаптации интерфейсов.

- Адаптер на основе объектов (Object Adapter):
    Использует композицию для адаптации интерфейсов.


Преимущества:

- Совместимость: Позволяет использовать классы с несовместимыми интерфейсами вместе.
- Гибкость: Можно адаптировать несколько классов с разными интерфейсами.
- Открытость/закрытость: Вы можете добавлять новые адаптеры, не изменяя существующий код.

Недостатки:

- Сложность: Может увеличить сложность кода из-за введения дополнительных классов.
- Ограничения: Не всегда удобно использовать, если интерфейсы слишком сильно различаются.

Когда использовать:

- Когда вы хотите использовать существующий класс, но его интерфейс не соответствует вашим требованиям.
- Когда вам нужно интегрировать сторонние библиотеки или компоненты с несовместимыми интерфейсами.
- Когда вы хотите создать повторно используемый класс, который работает с классами, не имеющими связи между собой.

Пример из реальной жизни:

- Адаптеры для работы с разными API: Например, если у вас есть приложение,
    которое работает с разными платежными системами, каждая из которых имеет свой API,
    вы можете создать адаптеры для каждой системы.

- Адаптеры для работы с базами данных: Если вы хотите использовать разные базы данных с разными интерфейсами,
    вы можете создать адаптеры для каждой из них.

'''


# Целевой интерфейс, который ожидает клиент
class Target:
    def request(self) -> str:
        return "Target: The default target's behavior."


# Класс с несовместимым интерфейсом
class Adaptee:
    def specific_request(self) -> str:
        return ".eetpadA eht fo roivaheb laicepS"


# Адаптер, который преобразует интерфейс Adaptee в интерфейс Target
class Adapter(Target):
    def __init__(self, adaptee: Adaptee):
        self.adaptee = adaptee

    def request(self) -> str:
        return f"Adapter: (TRANSLATED) {self.adaptee.specific_request()[::-1]}"


def client_code_1(target: Target) -> None:
    print(target.request())


# Создаем объект Adaptee
adaptee = Adaptee()

# Создаем адаптер и передаем ему Adaptee
adapter = Adapter(adaptee)

# Клиентский код работает с адаптером через интерфейс Target
client_code_1(adapter)

# Базовое поведение
target = Target()
client_code_1(target)


'''
Как это работает:

- Target — это интерфейс, который ожидает клиент.
- Adaptee — это класс с несовместимым интерфейсом, который нужно адаптировать.
- Adapter — это класс, который оборачивает Adaptee и предоставляет интерфейс, совместимый с Target.
'''
